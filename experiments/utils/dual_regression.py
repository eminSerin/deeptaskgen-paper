import os
import os.path as op
from glob import glob

import click
import nibabel as nib
import numpy as np
import pandas as pd
from joblib import Parallel, delayed
from scipy.stats import zscore
from tqdm import tqdm


def _gifti2array(gifti):
    """Converts a gifti image to a numpy array."""
    return np.array([gifti.darrays[i].data for i in range(len(gifti.darrays))])


def _spatial_regression(Y, X):
    """Performs spatial regression as a second step of dual regression.

    Adapted from:
    https://www.humanconnectome.org/storage/app/media/documentation/s900/HCP900_GroupICA+NodeTS+Netmats_Summary_15dec2015.pdf

    Parameters
    ----------
    Y : np.ndarray
        Subjects fMRI images (ts x vertices).
    X : np.ndarray
        Subjects ICA components (ts x components).
        Generated by the first stage of dual regression.

    Returns
    -------
    np.array
        Component values for each vertices (components x vertices).
    """
    pinvX = np.linalg.pinv(X)

    if X.shape[0] < 100:
        R = np.eye(X.shape[0]) - X.dot(pinvX)
        trR = np.trace(R)
        nu = np.round(np.trace(R) ** 2 / np.trace(R.dot(R)))
    else:
        nu = X.shape[0] - X.shape[1]
        trR = nu

    pe = pinvX.dot(Y)
    res = Y - X.dot(pe)
    sigsq = (np.sum(res**2, axis=0) / trR).reshape((1, -1))

    varcope = np.diag(pinvX.dot(pinvX.T)).reshape((-1, 1)).dot(sigsq)

    return pe / np.sqrt(varcope)


def _extract_timeseries(img, ica):
    """Extract timeseries from fMRI image using group-ICA components.

    Parameters
    ----------
    img : numpy.ndarray
        Image data (ts x vertices).
    ica_dir : numpy.ndarray
        ICA components (components x vertices).

    Returns
    -------
    timeseries : np.ndarray
        Parcellated timeseries.
    """
    # Extract timeseries.
    img = img - np.mean(img, axis=0)  # demean over time
    pGM = np.linalg.pinv(ica.transpose() - np.mean(ica, axis=1))
    return pGM.dot(img.T).transpose()  # solve for time series


def dual_regression(img_dir, ica_dir, output_nmap=None, output_ts=None, save=True):
    """Performs dual regression.

    The current implementation only supports GIFTI or CIFTI images.

    IMPORTANT: Make sure that the input image and the ICA components
    are in the same space and from the same hemisphere!

    Parameters
    ----------
    img_dir : str
        Path to image.
    ica_dir : str
        Path to ICA components.
    output_nmap : str, optional
        Path to output node map, by default None
    output_ts : str, optional
        Path to output timeseries, by default None
    save : bool, optional
        Whether  to save images or return, by default True
        If save=True, timeseries will be saved as .csv file,
        and node map as .func.gii file. Otherwise, timeseries
        and node map will be returned as numpy arrays.

    Returns
    -------
    str or np.ndarray
        If save=True, returns path to timeseries and node map.
        Otherwise, returns timeseries and node map as numpy arrays.

    Raises
    ------
    ValueError
        If input image is not GIFTI or CIFTI.
    ValueError
        If ICA components are not in the GIFTI for CIFTI formats.
    """
    nib.imageglobals.logger.setLevel(40)
    img = nib.load(img_dir)
    ica = nib.load(ica_dir)

    type_img = img.__class__.__name__
    type_ica = ica.__class__.__name__

    # Check input and atlas images.
    if type_img != "GiftiImage" and type_img != "Cifti2Image":
        raise ValueError("Input image is not a GIFTI or CIFTI image!")

    if type_ica != "GiftiImage" and type_ica != "Cifti2Image":
        raise ValueError("ICA components are not a GIFTI or CIFTI image!")

    # Extract data from images.
    if type_img == "GiftiImage":
        img_data = _gifti2array(img)
    else:
        img_data = img.get_fdata()
    if type_ica == "GiftiImage":
        ica_data = _gifti2array(ica)
    else:
        ica_data = ica.get_fdata()

    # Prepare output directories.
    if (output_ts is None) & (save is True):
        output_ts = img_dir.replace(".nii", "ICAts.csv")
    if (output_nmap is None) & (save is True):
        if type_img == "GiftiImage":
            output_nmap = img_dir.replace(".func.gii", "ICAnmap.func.gii")
        else:
            output_nmap = img_dir.replace(".nii", "ICAnmap.nii")

    # Extract timeseries
    ts = _extract_timeseries(img_data, ica_data)
    node_map = _spatial_regression(
        img_data - np.mean(img_data, axis=0), zscore(ts, axis=0)
    )

    if save is True:
        out_dir = op.dirname(op.realpath(output_ts))
        if op.exists(out_dir) is False:
            os.makedirs(out_dir)
        pd.DataFrame(ts).to_csv(output_ts, index=False, header=False)
        if type_img == "GiftiImage":
            nib.save(
                nib.gifti.gifti.GiftiImage(
                    darrays=[nib.gifti.gifti.GiftiDataArray(node_map)]
                ),
                output_nmap,
            )
        else:
            nib.save(
                nib.cifti2.cifti2.Cifti2Image(node_map, ica.header),
                output_nmap,
            )
        return output_ts, output_nmap
    return ts, node_map


def run_dual_regression(img, ica_dir, output_nmap=None, output_ts=None, save=True):
    """Wrapper function for dual-regression function."""
    return dual_regression(img, ica_dir, output_nmap, output_ts, save)


@click.command()
@click.argument("input_dir", type=click.Path())
@click.argument("ica_dir", type=click.Path(exists=True))
@click.argument("ext", type=click.STRING, default=".nii")
@click.option("--output_nmap", type=click.Path(exists=False), default=None)
@click.option("--output_ts", type=click.Path(exists=False), default=None)
@click.option("--save", type=bool, default=True)
@click.option("--task", type=str, default="restingstate")
@click.option("--hemi", type=click.Choice(["L", "R"]), default="L")
@click.option("--n_jobs", type=int, default=1)
def main(input_dir, ica_dir, ext, output_nmap, output_ts, save, task, hemi, n_jobs):
    if op.isfile(input_dir):
        input_dir = [input_dir]
    elif op.isdir(input_dir):
        if ext == ".nii" or ext == ".nii.gz":
            input_dir = glob.glob(op.join(input_dir, f"*{task}**{ext}*"))
        elif ext == ".func.gii":
            input_dir = sorted(
                glob(op.join(input_dir, "sub-*", f"*{task}*{hemi}.func.gii"))
            )
        else:
            raise ValueError(
                "Invalid image extension! Use .nii, nii.gz for CIFTI images or .func.gii for GIFTI images."
            )
    else:
        raise ValueError("Input directory does not exist!")

    Parallel(n_jobs=n_jobs)(
        delayed(run_dual_regression)(img, ica_dir, output_nmap, output_ts, save)
        for img in tqdm(input_dir)
    )


if __name__ == "__main__":
    main()
